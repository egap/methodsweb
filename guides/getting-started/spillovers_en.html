<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.280">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Alexander Coppock">

<title>Methods - 10 Things to Know About Spillovers</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../img/egap-logo.svg" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Methods</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../guides.html">
 <span class="menu-text">Guides</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../software.qmd">
 <span class="menu-text">Software</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../coursebook/index.html">
 <span class="menu-text">Coursebook</span></a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#abstract" id="toc-abstract" class="nav-link active" data-scroll-target="#abstract">Abstract</a></li>
  <li><a href="#what-they-are" id="toc-what-they-are" class="nav-link" data-scroll-target="#what-they-are">1. What they are</a></li>
  <li><a href="#if-ignored-spillovers-may-bias-treatment-effect-estimates" id="toc-if-ignored-spillovers-may-bias-treatment-effect-estimates" class="nav-link" data-scroll-target="#if-ignored-spillovers-may-bias-treatment-effect-estimates">2. If ignored, spillovers may “bias” treatment effect estimates</a></li>
  <li><a href="#most-experimental-analyses-implicitly-or-explicitly-assume-that-there-are-no-spillovers." id="toc-most-experimental-analyses-implicitly-or-explicitly-assume-that-there-are-no-spillovers." class="nav-link" data-scroll-target="#most-experimental-analyses-implicitly-or-explicitly-assume-that-there-are-no-spillovers.">3. Most experimental analyses implicitly or explicitly assume that there are no spillovers.</a></li>
  <li><a href="#you-need-some-kind-of-non-interference-assumption-whenever-you-try-to-estimate-spillover-effects" id="toc-you-need-some-kind-of-non-interference-assumption-whenever-you-try-to-estimate-spillover-effects" class="nav-link" data-scroll-target="#you-need-some-kind-of-non-interference-assumption-whenever-you-try-to-estimate-spillover-effects">4. You need some kind of non-interference assumption whenever you try to estimate spillover effects</a></li>
  <li><a href="#spillovers-are-only-indirectly-randomly-assigned" id="toc-spillovers-are-only-indirectly-randomly-assigned" class="nav-link" data-scroll-target="#spillovers-are-only-indirectly-randomly-assigned">5. Spillovers are only indirectly “randomly assigned”</a></li>
  <li><a href="#to-estimate-spillovers-you-need-to-account-for-differential-probabilities-of-assignment-to-the-spillover" id="toc-to-estimate-spillovers-you-need-to-account-for-differential-probabilities-of-assignment-to-the-spillover" class="nav-link" data-scroll-target="#to-estimate-spillovers-you-need-to-account-for-differential-probabilities-of-assignment-to-the-spillover">6. To estimate spillovers you need to account for differential probabilities of assignment to the spillover</a></li>
  <li><a href="#choosing-the-wrong-interference-assumption-will-yield-incorrect-estimates" id="toc-choosing-the-wrong-interference-assumption-will-yield-incorrect-estimates" class="nav-link" data-scroll-target="#choosing-the-wrong-interference-assumption-will-yield-incorrect-estimates">7. Choosing the wrong interference assumption will yield incorrect estimates</a></li>
  <li><a href="#sometimes-you-can-avoid-spillovers-with-buffer-rows" id="toc-sometimes-you-can-avoid-spillovers-with-buffer-rows" class="nav-link" data-scroll-target="#sometimes-you-can-avoid-spillovers-with-buffer-rows">8. Sometimes you can avoid spillovers with “buffer rows”</a></li>
  <li><a href="#there-are-other-design-based-approaches-for-detecting-spillover-effects." id="toc-there-are-other-design-based-approaches-for-detecting-spillover-effects." class="nav-link" data-scroll-target="#there-are-other-design-based-approaches-for-detecting-spillover-effects.">9. There are other design-based approaches for detecting spillover effects.</a></li>
  <li><a href="#even-if-a-treatment-is-binary-spillovers-might-not-be.-the-right-model-might-require-dealing-with-dosage" id="toc-even-if-a-treatment-is-binary-spillovers-might-not-be.-the-right-model-might-require-dealing-with-dosage" class="nav-link" data-scroll-target="#even-if-a-treatment-is-binary-spillovers-might-not-be.-the-right-model-might-require-dealing-with-dosage">10. Even if a treatment is binary, spillovers might not be. The right model might require dealing with “dosage”</a></li>
  <li><a href="#for-further-reading" id="toc-for-further-reading" class="nav-link" data-scroll-target="#for-further-reading">For further reading</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">10 Things to Know About Spillovers</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Authors</div>
    <div class="quarto-title-meta-contents">
             <p>Alexander Coppock </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<section id="abstract" class="level1">
<h1>Abstract</h1>
<p>This guide<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> helps you think through how to design and analyze experiments when there is a risk of “interference” between units. This has been an important area of research in recent years and there have been real gains in our understanding of how to detect spillover effects. Spillovers arise whenever one unit is affected by the treatment status of another unit. Spillovers make it difficult to work out causal effects (we say why below). Experimentalists worry a lot about them, but the complications that spillovers create are not unique to randomized experiments.</p>
</section>
<section id="what-they-are" class="level1">
<h1>1. What they are</h1>
<p>Spillovers refer to a broad class of instances in which a given subject is influenced by whether other subjects are treated.</p>
<p>Here are some examples of how spillovers (or “interference”) might occur:</p>
<ul>
<li><strong>Public Health:</strong> Providing an infectious disease vaccine to some individuals may decrease the probability that nearby individuals become ill.</li>
<li><strong>Criminology:</strong> Increased enforcement may displace crime to nearby areas.</li>
<li><strong>Education:</strong> Students may share newly acquired knowledge with friends.</li>
<li><strong>Marketing:</strong> Advertisements displayed to one person may increase product recognition among her work colleagues.</li>
<li><strong>Politics:</strong> Election monitoring at some polling stations may displace fraud to neighboring polling stations.</li>
<li><strong>Economics:</strong> Lowering the cost of production for one firm may change the market price faced by other firms.</li>
<li><strong>Within-subjects experiments across many domains:</strong> the possibility that treatment effects persist or that treatments are anticipated can be modeled as a kind of spillover.</li>
</ul>
<p>These examples share some features:</p>
<ul>
<li>An <em>intervention</em>: the vaccine, increased enforcement, election monitoring;</li>
<li>An <em>outcome</em>: incidence of disease, crime rates, electoral fraud; and</li>
<li>A “<em>network</em>” that links units together: face-to-face social interaction, geographic proximity within a city, road distance between polling stations.</li>
</ul>
<p>The network is a crucial feature of any spillover analysis. For each unit, it describes the set of other units whose treatment assignments “matter.” To take the education example: it may matter to me if you treat another student in my classroom, but it probably doesn’t matter if you treat a student in a different city. I’m connected to the other students in my classroom but not to students in other cities.</p>
</section>
<section id="if-ignored-spillovers-may-bias-treatment-effect-estimates" class="level1">
<h1>2. If ignored, spillovers may “bias” treatment effect estimates</h1>
<p>If unaddressed, spillovers “bias” standard estimates of treatment effects (e.g., differences-in-means). “Bias” is in scare quotes because those estimators will return unbiased estimates of causal effects, just not the causal effects that most researchers are interested in.</p>
<p>Imagine an experiment in which there are 50 villages. A treatment (such as a vaccination program) is randomly assigned to some villages but not others. Let’s assume that a village receives spillovers if another village within a 5km radius is treated. Imagine the outcome is some measure of health (such as the prevalence of an infectious disease). If we naively compare treated villages to untreated villages, we may not recover an unbiased estimate of the direct effect of treating a village. The reason is that each village’s outcome is affected not only by whether that village is treated, but also by whether neighboring villages are treated.</p>
<p>In order to see how spillovers can distort estimated treatment effects, consider the graph below:</p>
<p><img src="https://raw.githubusercontent.com/egap/methods-guides/master/spillovers/spilloverbias.jpg" class="img-fluid"></p>
<p>The graph considers a situation in which the true direct effect of treating a village is 1, and shows how estimated treatment effects can be higher or lower than 1 depending on the direction and size of spillovers as well as the number of villages treated.</p>
<p>In this case, positive spillovers cause a negative bias and vice-versa. This is because when spillovers are positive, the control group mean is inflated, so the difference-in-means is smaller than it otherwise would have been.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> The extent of the bias, however, depends on the number of villages treated as well as the magnitude of the spillover effect. In this example, the more villages are treated, the smaller the bias resulting from spillovers. This is because when more villages are treated, both the treatment and control group means are similarly inflated by positive spillovers and deflated by negative spillovers.</p>
<p>Often, evaluators are trying to estimate what would happen if a program were rolled out to everyone. Evidence from an RCT that ignores spillover could greatly over or underestimate the total effects of the intervention.</p>
</section>
<section id="most-experimental-analyses-implicitly-or-explicitly-assume-that-there-are-no-spillovers." class="level1">
<h1>3. Most experimental analyses implicitly or explicitly assume that there are no spillovers.</h1>
<p>The assumption that there are no spillovers is known as the <strong>non-interference assumption</strong>; it is part of a somewhat more elaborate assumption sometimes referred to as the <strong>Stable Unit Treatment Value Assumption</strong> (or SUTVA) that is usually invoked in causal inference.</p>
<p>What does the non-interference assumption mean? Subjects can only reveal one of two “potential outcomes”: either their treated outcome or their untreated outcome. Which of these they reveal depends on their own treatment status only. The treatment status of all the other subjects in the experiment doesn’t matter at all.</p>
<p>We can state the non-interference assumption more formally using potential outcomes notation: <span class="math inline">\(y_i(z_i,Z)=y_i(z′_i,Z′)\)</span>, if <span class="math inline">\(z_i=z′_i\)</span>, where <span class="math inline">\(Z\)</span> and <span class="math inline">\(Z′\)</span> represent any two possible random assignment vectors. In words, this expression states that subject <span class="math inline">\(i\)</span> is unaffected by other subjects’ treatment assignments.</p>
<p>How reasonable is the non-interference assumption? The answer depends on the domain. Every study that finds a statistically significant impact of spillovers is providing evidence that the assumption is incorrect in that particular application. Most papers discussing spillovers tend to focus on examples in which the non-interference assumption is false. But other studies suggest that spillovers are sometimes surprisingly weak. Sinclair, McConnell, and Green (2012) for example find no evidence of within-zip code spillovers of experimental encouragements to vote, bolstering the non-interference claims made by the dozens of previous turnout experiments.</p>
</section>
<section id="you-need-some-kind-of-non-interference-assumption-whenever-you-try-to-estimate-spillover-effects" class="level1">
<h1>4. You need some kind of non-interference assumption whenever you try to estimate spillover effects</h1>
<p>The usual non-interference assumption is very strong: it says that there are no spillover effects. When you try to estimate spillovers, you are replacing this strong assumption with a (slightly) weaker one. Perhaps you think that spillovers take place in geographic space — the treatment status of one location may influence the outcomes of nearby units. Allowing spillovers to take place in geographic space requires the assumption that they do not also occur in, for example, social space. This assumption would be violated if the treatment status of, say, Facebook friends in faraway places affects which potential outcome is revealed. To restate this point more generally: When you relax the non-interference assumption, you replace it with a new assumption: no unmodeled spillovers. The modeling of spillovers itself requires strong, often untestable assumptions about how spillovers can and cannot occur.</p>
<p>Suppose we were to model spillovers in the following way. Every unit has four potential outcomes, which we’ll write as <span class="math inline">\(Y(Z_i,Z_j)\)</span>, where <span class="math inline">\(Z_i\)</span> refers to a unit’s own treatment assignment, and <span class="math inline">\(Z_j\)</span> refers to the treatment assignment of neighboring units (i.e., other units within a specified radius). <span class="math inline">\(Z_j=1\)</span> when any neighboring units are treated and <span class="math inline">\(Z_j=0\)</span> otherwise.</p>
<ul>
<li><span class="math inline">\(Y_{00} \equiv Y(Z_i=0,Z_j=0)\)</span>: Pure Control</li>
<li><span class="math inline">\(Y_{10} \equiv Y(Z_i=1,Z_j=0)\)</span>: Directly treated, no spillover</li>
<li><span class="math inline">\(Y_{01} \equiv Y(Z_i=0,Z_j=1)\)</span>: Untreated, with spillover</li>
<li><span class="math inline">\(Y_{11} \equiv Y(Z_i=1,Z_j=1)\)</span>: Directly treated, with spillover</li>
</ul>
<p>What assumptions are we invoking here? First, we are stipulating that the treatment assignments of non-neighboring units do not alter a unit’s potential outcomes. Second, we are modeling spillovers as a binary event: either some neighboring unit is treated, or not — we are ignoring the <em>number</em> of neighboring units that are treated, and indeed, their relative proximity.</p>
<p>This potential outcome space is already twice as complex as the one allowed by the conventional non-interference assumption. However, it is important to bear in mind that this potential outcome space can be incorrect in the sense that it does not accurately reflect the underlying social process at work in the experiment.</p>
</section>
<section id="spillovers-are-only-indirectly-randomly-assigned" class="level1">
<h1>5. Spillovers are only indirectly “randomly assigned”</h1>
<p>The beauty of randomized experiments is that treatment assignments are directly under the control of the researcher. Interestingly in an experiment, spillovers are also randomly determined by the treatment assignment – after all, you’re assigning some unit’s neighbor to treatment or control on a random basis. The trouble is that the probability that a unit is in a spillover condition is no longer directly under the control of the experimenter. Units that are close to many other units, for example, might be more likely to be in the spillover condition than units that are off on their own.</p>
<p>Take a look at the graph below of 50 units arrayed in geographic space. The 10 red units (both filled and unfilled) were randomly selected for direct treatment and yellow units for control. A filled point represents a unit in a spillover condition, whereas an unfilled point represent a unit that has no treated neighbors within the 5km radius. Notice that the units closer to the center of the graph have a much higher chance of being in a spillover condition than do units towards the edges.</p>
<p><img src="https://raw.githubusercontent.com/egap/methods-guides/master/spillovers/spilloversradius.jpg" class="img-fluid"></p>
</section>
<section id="to-estimate-spillovers-you-need-to-account-for-differential-probabilities-of-assignment-to-the-spillover" class="level1">
<h1>6. To estimate spillovers you need to account for differential probabilities of assignment to the spillover</h1>
<p>When we estimate causal effects, we have to take account of the probability with which units are assigned to a given treatment condition. Sometimes this is done through matching; sometimes it is done using inverse probability weighting (IPW).</p>
<p>Sometimes, the only practical way to calculate assignment probabilities is through computer simulation (though analytic probabilities can be calculated for some designs). For example you could conduct 10,000 simulated random assignments and count up how often each unit is in each of the four conditions described in the previous section. In R:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define two helper functions</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>complete_ra <span class="ot">&lt;-</span> <span class="cf">function</span>(N,m){</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  assign <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(<span class="dv">1</span><span class="sc">:</span>N <span class="sc">%in%</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span>N,m),<span class="dv">1</span>,<span class="dv">0</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(assign)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>get_condition <span class="ot">&lt;-</span> <span class="cf">function</span>(assign, adjmat){</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  exposure <span class="ot">&lt;-</span>  adjmat <span class="sc">%*%</span> assign</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  condition <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="st">"00"</span>, <span class="fu">length</span>(assign))</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  condition[assign<span class="sc">==</span><span class="dv">1</span> <span class="sc">&amp;</span> exposure<span class="sc">==</span><span class="dv">0</span>] <span class="ot">&lt;-</span> <span class="st">"10"</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  condition[assign<span class="sc">==</span><span class="dv">0</span> <span class="sc">&amp;</span> exposure<span class="sc">&gt;</span><span class="dv">0</span>] <span class="ot">&lt;-</span> <span class="st">"01"</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  condition[assign<span class="sc">==</span><span class="dv">1</span> <span class="sc">&amp;</span> exposure<span class="sc">&gt;</span><span class="dv">0</span>] <span class="ot">&lt;-</span> <span class="st">"11"</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(condition)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="dv">50</span>  <span class="co"># total units</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>m <span class="ot">&lt;-</span> <span class="dv">20</span>  <span class="co"># Number to be treated</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate adjacency matrix</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">343</span>)</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>coords <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">rnorm</span>(N<span class="sc">*</span><span class="dv">2</span>)<span class="sc">*</span><span class="dv">10</span>, <span class="at">ncol =</span> <span class="dv">2</span>)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>distmat <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(<span class="fu">dist</span>(coords))</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>true_adjmat <span class="ot">&lt;-</span> <span class="dv">1</span> <span class="sc">*</span> (distmat<span class="sc">&lt;=</span><span class="dv">5</span>) <span class="co"># true radius = 5</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="fu">diag</span>(true_adjmat) <span class="ot">&lt;-</span><span class="dv">0</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Run simulation 10000 times</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>Z_mat <span class="ot">&lt;-</span> <span class="fu">replicate</span>(<span class="dv">10000</span>, <span class="fu">complete_ra</span>(<span class="at">N =</span> N, <span class="at">m =</span> m))</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>cond_mat <span class="ot">&lt;-</span> <span class="fu">apply</span>(Z_mat, <span class="dv">2</span>, get_condition, <span class="at">adjmat=</span>true_adjmat)</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculate assignment probabilities</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>prob00 <span class="ot">&lt;-</span> <span class="fu">rowMeans</span>(cond_mat<span class="sc">==</span><span class="st">"00"</span>)</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>prob01 <span class="ot">&lt;-</span> <span class="fu">rowMeans</span>(cond_mat<span class="sc">==</span><span class="st">"01"</span>)</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>prob10 <span class="ot">&lt;-</span> <span class="fu">rowMeans</span>(cond_mat<span class="sc">==</span><span class="st">"10"</span>)</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>prob11 <span class="ot">&lt;-</span> <span class="fu">rowMeans</span>(cond_mat<span class="sc">==</span><span class="st">"11"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can display the resulting probabilities plotted below against the number of units within the 5km radius. The further from the center a unit is, the higher the probability of not being in the spillover condition.</p>
<p><img src="https://raw.githubusercontent.com/egap/methods-guides/master/spillovers/spilloverprobabilities.jpg" class="img-fluid"></p>
<p>We must account for these differential probabilities of assignment using IPW. Below is a block of R code that shows how to include IPWs in a regression context.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define helper functions</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>get_prob <span class="ot">&lt;-</span> <span class="cf">function</span>(cond,prob00,prob01,prob10, prob11){</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  prob <span class="ot">&lt;-</span> prob00</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  prob[cond<span class="sc">==</span><span class="st">"10"</span>] <span class="ot">&lt;-</span> prob10[cond<span class="sc">==</span><span class="st">"10"</span>]</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  prob[cond<span class="sc">==</span><span class="st">"01"</span>] <span class="ot">&lt;-</span> prob01[cond<span class="sc">==</span><span class="st">"01"</span>]</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  prob[cond<span class="sc">==</span><span class="st">"11"</span>] <span class="ot">&lt;-</span> prob11[cond<span class="sc">==</span><span class="st">"11"</span>]</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(prob)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>get_Y <span class="ot">&lt;-</span> <span class="cf">function</span>(cond, Y00, Y01, Y10, Y11){</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  Y <span class="ot">&lt;-</span> Y00</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>  Y[cond<span class="sc">==</span><span class="st">"10"</span>] <span class="ot">&lt;-</span> Y10[cond<span class="sc">==</span><span class="st">"10"</span>]</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  Y[cond<span class="sc">==</span><span class="st">"01"</span>] <span class="ot">&lt;-</span> Y01[cond<span class="sc">==</span><span class="st">"01"</span>]</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>  Y[cond<span class="sc">==</span><span class="st">"11"</span>] <span class="ot">&lt;-</span> Y11[cond<span class="sc">==</span><span class="st">"11"</span>]</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(Y)</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate potential outcomes as a function of position</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>Y00 <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(N)</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Treatment Effects</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>t10 <span class="ot">&lt;-</span> <span class="dv">10</span>   <span class="co"># direct effect</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>t01 <span class="ot">&lt;-</span> <span class="sc">-</span><span class="dv">3</span>   <span class="co"># indirect effect</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>t11 <span class="ot">&lt;-</span> <span class="dv">5</span>    <span class="co"># direct + indirect</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>Y01 <span class="ot">&lt;-</span> Y00 <span class="sc">+</span> t01</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>Y10 <span class="ot">&lt;-</span> Y00 <span class="sc">+</span> t10</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>Y11 <span class="ot">&lt;-</span> Y00 <span class="sc">+</span> t11</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Randomly generate treatment assignment</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>assign <span class="ot">&lt;-</span> <span class="fu">complete_ra</span>(N, m)</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a><span class="co"># Reveal true conditions</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>cond <span class="ot">&lt;-</span> <span class="fu">get_condition</span>(<span class="at">assign =</span> assign, <span class="at">adjmat =</span> true_adjmat)</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a><span class="co"># Reveal potential outcomes</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>Y <span class="ot">&lt;-</span> <span class="fu">get_Y</span>(<span class="at">cond =</span> cond, <span class="at">Y00 =</span> Y00, <span class="at">Y01=</span>Y01, <span class="at">Y10=</span>Y10, <span class="at">Y11=</span>Y11)</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a><span class="co"># calculate weights</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>weights <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">/</span><span class="fu">get_prob</span>(<span class="at">cond=</span>cond, <span class="at">prob00=</span>prob00,<span class="at">prob01=</span>prob01,<span class="at">prob10=</span>prob10,<span class="at">prob11=</span>prob11)</span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a><span class="co"># combine data into a dataframe</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(Y, cond, weights, prob00, prob01, prob10, prob11)</span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a><span class="co"># conduct estimation comparing the spillover condition to the pure control</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>fit <span class="ot">&lt;-</span> <span class="fu">lm</span>(Y <span class="sc">~</span> cond<span class="sc">==</span><span class="st">"01"</span>, <span class="at">weights=</span>weights,</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>          <span class="at">data =</span> <span class="fu">subset</span>(df, prob00 <span class="sc">&gt;</span><span class="dv">0</span> <span class="sc">&amp;</span> prob00 <span class="sc">&lt;</span><span class="dv">1</span> <span class="sc">&amp;</span> prob01 <span class="sc">&gt;</span><span class="dv">0</span> <span class="sc">&amp;</span> prob01 <span class="sc">&lt;</span> <span class="dv">1</span> <span class="sc">&amp;</span> cond <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"00"</span>, <span class="st">"01"</span>)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>There are two very important things to remember when using IPW:</p>
<ul>
<li>Only include units that have a non-zero and non-one probability of being in all conditions being compared. The code above only compares the pure control condition to the untreated spillover condition (see the subsetting in the lm call).</li>
<li>Remember the IPW mantra: units are weighted by the inverse of the probability of being in the condition that they are in.</li>
</ul>
</section>
<section id="choosing-the-wrong-interference-assumption-will-yield-incorrect-estimates" class="level1">
<h1>7. Choosing the wrong interference assumption will yield incorrect estimates</h1>
<p>You might be tempted to simply construct a model for a particular type of spillover and estimate it. But unfortunately, just as spillovers can produce biased estimates of treatment effects, incorrectly modeled spillovers can create biased estimates of spillover effects (as well as treatment effects).</p>
<p>To get some intuition for the problem, the simulator below lets you pick an interference assumption: the radius beyond which spillovers cannot occur. As in section 4, we assume there are only 4 potential outcomes. The three causal effects that interest us are the average differences between <span class="math inline">\(Y_{00}\)</span> and the other three potential outcomes. The tension in the simulator is between the true (in principle, unknown) spillover network that generates outcomes and the assumed spillover network used for estimation.</p>
<p>The causal effect estimates are only correct when the spillover assumption is correct. The potential outcomes were generated under a true radius of 5km. When any radius other than 5km is selected, some if not all of the estimates are biased. This simulator underlines a discouraging point about spillover analysis: it is generally not possible to know if you’ve got the “correct” model of spillovers. Short of doing so, the answers yielded by the model will be incorrect.</p>
<iframe height="500" src="https://egap.shinyapps.io/spillover-app/" width="850">
</iframe>
<p><a href="https://github.com/egap/shiny/tree/master/gotv-app">Download R code for the above Shiny App</a> from github</p>
<p>Applied researchers often favor two responses to the “unknowability” of the spillover process. First, they specify “theoretically-driven” models of spillover. Usually, this involves the careful application of qualitative information from the experimental context. Second, researchers conduct robustness checks: they present estimates under a series of spillover assumptions, for example the estimates under increasing radii.</p>
</section>
<section id="sometimes-you-can-avoid-spillovers-with-buffer-rows" class="level1">
<h1>8. Sometimes you can avoid spillovers with “buffer rows”</h1>
<p>One approach to addressing the problem of spillovers is to ensure that other units’ treatment assignments cannot interfere with potential outcomes, by including “buffer rows” between experimental units. The buffer row analogy comes from agricultural studies in which experimental crop rows were physically separated by non-experimental rows that presumably prevented interference due to local changes in soil nitrogen content, insect behavior, or water usage.</p>
<p>The analogous design choice in our villages experiment would be to sample a set of 50 experimental villages from a larger set of villages, such that all 50 experimental villages were a healthy distance away from each other – say, separated by a minimum of 75km. Of course, we still must make a non-interference assumption along the lines of: “No spillovers between villages that are 75km or more apart.” This assumption also rules out spillovers that might take place over non-geographic networks, such as an information network via radio, telephone, or internet.</p>
<p>The main advantage of buffer-row-inspired design is the massive reduction in complexity. You can get a clean estimate of a direct treatment effect using standard analytic techniques, without needing to posit complicated assumptions about the possible avenues for spillover.</p>
<p>The main disadvantage of this design, however, is that by design you cannot estimate natural spillover patterns — which could be critical in understanding normal social processes. (Note: if you do do a buffer design, don’t ignore the buffers themselves — data on these can give you a better handle on spillover effects even though they are never going to receive treatment directly.)</p>
</section>
<section id="there-are-other-design-based-approaches-for-detecting-spillover-effects." class="level1">
<h1>9. There are other design-based approaches for detecting spillover effects.</h1>
<p>Some researchers employ a “multilevel” design for exploring spillover effects. The “levels” of the experiment correspond to the spillover network. For example, Sinclair, McConnell, and Green (2012) employ a multilevel design to investigate the possible spillover effects of an encouragement to vote. The levels in their experiment are the neighborhood (nine-digit ZIP code), the household, and the individual. The authors’ non-interference assumption is that the treatment assignments of units in other neighborhoods do not matter. What determines which potential outcome is revealed is a combination of three things:</p>
<ul>
<li>An individual’s own treatment assignment</li>
<li>The treatment assignment of his or her housemate</li>
<li>The treatment assignment of others in the neighborhood</li>
</ul>
<p>Following a relatively complex randomization scheme, the authors assigned treatments so as to create variation in all three levels.</p>
<p>What are the advantages of this design? First, it requires the researcher to stipulate a non-interference assumption ex ante, so there can be no question of fiddling around with interference assumptions until a statistically significant result pops up. Second, it assigns individuals to treatment (including spillover) conditions with known probabilities, so IPW can proceed without having to resort to the simulation method discussed above.</p>
<p>What are the disadvantages? As ever, the difficulty is that the non-interference assumption used in the design stage could be wrong. Perhaps there are significant spillovers across neighborhoods – after all, neighborhood boundaries as described by nine-digit ZIP codes are arbitrary; it could be that the best of friends happen to straddle these boundaries. Or it could be that the spillover network is only indirectly governed by geography. Workplace social ties may be the true means by which the treatment assignment of one unit influences the outcome expressed by others. Of course, nothing about a multilevel randomization scheme prevents the exploration of such alternative spillover structures.</p>
</section>
<section id="even-if-a-treatment-is-binary-spillovers-might-not-be.-the-right-model-might-require-dealing-with-dosage" class="level1">
<h1>10. Even if a treatment is binary, spillovers might not be. The right model might require dealing with “dosage”</h1>
<p>We’ve explored a non-parametric approach to estimating spillover effects. (See Aronow and Samii 2015 for a fuller treatment of this method as well as a conservative variance estimator in the presence of spillovers.) Units were randomly assigned to one of four conditions with a complex (but knowable) probability. Our estimates of causal effects were calculated as differences in weighted average outcomes between the treatment conditions. This approach has the advantage of making IPW estimation easy – simply weight each observation by the inverse of the probability of it being in the condition that it’s in.</p>
<p>But what about “dosage”? Perhaps in fact spillovers work as a decreasing function of the distance to every other treated unit or in some other more complex way. The spillover is then a continuous variable that describes the “dosage” of exposure to spillovers. The non-parametric IPW approach would require us to chop up the continuous variable in to bins and then calculate average outcomes according to the bin. The IPW estimator quickly becomes quite noisy, as fewer and fewer units occupy each bin.</p>
<p>Bowers, Fredrickson, and Panagopoulos (2013) propose a framework that can accommodate any causal model that maps treatment assignments into potential outcomes. The potential outcomes can be in discrete categories (as we’ve been assuming for most of this guide) or a continuous function of the dosage of spillovers.</p>
<p>A schematic sketch of their method is as follows. Suppose the causal model has two parameters: <span class="math inline">\(\beta_1\)</span>, the direct treatment effect and <span class="math inline">\(\beta_2\)</span>, the indirect effect of a single unit of spillover dosage. A joint test of the hypothesis that <span class="math inline">\(\beta_1 = \beta_2 = 0\)</span> is equivalent to a test of the sharp null hypothesis of no effect. Such a test yields a p-value — the probability that the observed data were generated according to the causal model in which <span class="math inline">\(\beta_1 = \beta_2 = 0\)</span>.</p>
<p>But we aren’t restricted to only obtaining p-values for the hypothesis that <span class="math inline">\(\beta_1 = \beta_2 = 0\)</span>. Those parameters could take on any values, and we could associate a p-value with any hypothesized pair of values. The essence of their proposed estimation method is to pick the pair that generates the highest p-value by searching through the set of plausible pairs.</p>
</section>
<section id="for-further-reading" class="level1">
<h1>For further reading</h1>
<p>Aronow, Peter M., and Cyrus Samii (2015). “Estimating Average Causal Effects Under Interference Between Units.” <a href="http://arxiv.org/abs/1305.6156">arXiv</a></p>
<p>Athey, Susan, and Guido W. Imbens (2017a). “The Econometrics of Randomized Experiments.” In <em>Handbook of Economic Field Experiments</em>, vol.&nbsp;1 (E. Duflo and A. Banerjee, eds.). <a href="http://arxiv.org/abs/1607.00698">arXiv</a> <a href="http://dx.doi.org/10.1016/bs.hefe.2016.10.003">DOI</a></p>
<p>Athey, Susan, and Guido W. Imbens (2017b). <a href="http://doi.org/10.1257/jep.31.2.3">“The State of Applied Econometrics: Causality and Policy Evaluation.”</a> <em>Journal of Economic Perspectives</em> 31(2): 3–32.</p>
<p>Bowers, Jake, Mark M. Fredrickson, and Costas Panagopoulos (2013). “Reasoning about Interference Between Units: A General Framework.” <em>Political Analysis</em> 21: 97–124.</p>
<p>Gerber, Alan S., and Donald P. Green (2012). <em>Field Experiments: Design, Analysis, and Interpretation</em>, chapter 8.</p>
<p>Glennerster, Rachel, and Kudzai Takavarasha (2013). <em>Running Randomized Evaluations: A Practical Guide</em>, modules 4.2, 7.3, and 8.2.</p>
<p>Paluck, Elizabeth Levy, Hana Shepherd, and Peter M. Aronow (2016). “Changing Climates of Conflict: A Social Network Experiment in 56 Schools.” <em>Proceedings of the National Academy of Sciences</em> 113: 566–571.</p>
<p>Sinclair, Betsy, Margaret McConnell, and Donald P. Green (2012). “Detecting Spillover Effects: Design and Analysis of Multilevel Experiments.” <em>American Journal of Political Science</em> 56: 1055–1069.</p>


</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Originating author: Alex Coppock, 31 Jul 2014. Minor revisions: Don Green and Winston Lin, 20 July 2016. The guide is a live document and subject to updating by EGAP members at any time; contributors listed are not responsible for subsequent edits.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Note though, it is generally very difficult to guess the direction of the bias that would be induced by spillover. Claims like, “spillover would only make our treatment effects appear stronger” usually depend on assumptions of treatment (and spillover) effect homogeneity.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>